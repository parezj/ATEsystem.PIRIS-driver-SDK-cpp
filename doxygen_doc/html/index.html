<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ATEsystem.PIRIS-driver: ATEsystem PIRIS C++ SDK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="./ate_logo+claim_vertical_color_orez_1250x380.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ATEsystem.PIRIS-driver
   &#160;<span id="projectnumber">1.0.1</span>
   </div>
   <div id="projectbrief">ATEsystem.PIRIS-driver</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">ATEsystem PIRIS C++ SDK </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>ATEsystem.PIRIS-driver is part of software support for P-IRIS Controller product. It serves as a main interface between the hardware and the control application. The driver allows complete control of the controller unit in both <b>UART/Ethernet</b> and <b>RS232</b> version. It implements a proprietary ATEsystem communication protocol which is described in the datasheet of the controller.</p>
<img src="./PIRIS.png" alt="image" class="inline"/>
<p>The driver is written in C++ 17 and is distributed in the form of source code under MIT licence. The software requires following dependencies: </p><div class="fragment"><div class="line">Pylon 5.0.12</div><div class="line">VC++ Redistributable 2013 and 2017 (Windows only) </div></div><!-- fragment --><p> <a href="https://www.baslerweb.com/en/sales-support/downloads/software-downloads/pylon-5-0-12-windows/">https://www.baslerweb.com/en/sales-support/downloads/software-downloads/pylon-5-0-12-windows/</a></p>
<p><a href="https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads">https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads</a></p>
<p>The driver uses Serial open-source software. The dependencies are distributed in two folders, bin and install, and are necessary for proper function. The driver (including its dependencies) is multi-platform. The distribution includes executable examples for both <b>Windows OS (x86, amd64)</b> and <b>Linux OS (x86, amd64, armhf, arm64)</b>. The SDK has been developed in Microsoft Visual Studio 2017 IDE which allows multi-platform development of C++ applications. IDE settings and further details can be found below. </p><h3>Installation</h3>
<p>Upon extraction of the distributed archive open the Solution in Visual Studio 2017 using the included SLN file. <b>Linux</b> and <b>WinNT</b> folders include VS projects with corresponding settings of compiler and linker, separately for x86, amd64, armhf and arm64 architectures. <b>Shared</b> folder is the main container which includes the source code of the driver, header files, libraries and examples. <b>Bin</b> folder includes executable examples.</p>
<p>The source code of the driver is divided in four folders <em>bin, include, lib</em> and <em>src</em>: <b>Bin</b> includes separate binary files for each of the supported architectures. The binaries are Pylon and GenICam dynamic libraries, which must be installed on the target machine. There is also a batch file prepared for Windows OS, however it is acceptable to install Pylon 5 runtime from the official distribution. <b>Lib</b> includes static libraries for Windows OS.</p>
<p><b>Include</b> incorporates header files for the driver, ATEsystem.PIRIS is the main header file and the only one, which must be included in the application which uses the driver. <b>Pylon</b> and <b>serial</b> include corresponding header files for UART/Ethernet and RS232 unit.</p>
<p><b>Src</b> includes complete source code. The source code of the driver is located directly in the root of this folder, source files for multiplatform manipulation with serial ports (created by William Woodall and John Harrison) are in folder <b>serial</b>.</p>
<p>The root folder includes a few demonstrations of usage of the driver, named <b>example</b>. File <em><a class="el" href="example_8cpp.html">example.cpp</a></em> is the main demonstration file, files with suffixes *_ethernet* and *_serial* include examples based on the chosen mode. Corresponding executable binary files of this example can be found */bin* folder in the root. </p><h3>IDE settings</h3>
<p>Build tools must be properly set up in order to create an executable file from the source code. Settings of the compiler, linker and other important parameters is described as in Microsoft Visual Studio 2017 Enterprise IDE. Settings in Configuration Properties &gt; VC++ Directories &gt; <b>Include Directories</b> must be set as follows: </p><div class="fragment"><div class="line">1)  $(SolutionDir)\ATEsystem.PIRIS-driver-Shared\include\pylon\WinNT</div><div class="line">2)  $(SolutionDir)\ATEsystem.PIRIS-driver-Shared\include\serial</div><div class="line">3)  $(SolutionDir)\ATEsystem.PIRIS-driver-Shared\include</div></div><!-- fragment --><p> Value in Configuration Properties &gt; Linker &gt; General &gt; <b>Additional Library Directories</b> must be changed to the path of the static Pylon library from lib/pylon (for corresponding architecture). </p><div class="fragment"><div class="line">1)  $(SolutionDir)\ATEsystem.PIRIS-driver-Shared\lib\pylon\Win32</div></div><!-- fragment --><p> Settings in Configuration Properties &gt; Linker &gt; Input &gt; <b>Additional Dependencies</b> must include the name of static Pylon library and in case of Windows-based target also the name of <em>Setupapi</em> library. </p><div class="fragment"><div class="line">1)  PylonBase_MD_VC120_v5_0.lib</div><div class="line">2)  Setupapi.lib</div></div><!-- fragment --><p> Value in Configuration Properties &gt; C/C++ &gt; <b>Language</b> must be set to <em>ISO C++17 Standard</em>. </p><div class="fragment"><div class="line">ISO C++ 17 Standard (/std:c++17)</div></div><!-- fragment --> <h3>Usage</h3>
<p>In order to successfully use the driver following objects are necessary: <b>Factory</b> (Singleton) class and <b>IPiris</b> interface, which is in fact implemented as a Smart Pointer; data containers (<b>DataID</b>, <b>DataPosition</b>, <b>DataParams</b> a <b>DataState</b>), which are returned using std::tuple collection and StatusEx object, which carries basic information on performed action, including error code, error message of the device <b>ErrorCluster</b> and error message of the driver <b>Status</b>.</p>
<p><em>Factory</em> is a class based on the Factory design pattern. It serves to create instances of the driver for particular communication interface (UART/Ethernet : <b>CPirisEthernet</b>, RS232 : <b>CPirisSerial</b>). Multiple such instances can be created and used parallelly with the help of one instance of the factory, <em>DevID_t</em> serves as an identifier. The identifier can be used to create or delete the instances or to access the interfaces of the instance. As the interface is implemented as a Smart Pointer, there is no need to call delete, nor to use RemoveDevice() function, which is suitable for management of more than one instance of the driver. This system allows to use more P-IRIS Controller units at once, transparently and without any risk of memory leak. </p><div class="fragment"><div class="line">DevID_t CreateDevice(Mode mode = Mode::ETHERNET);</div><div class="line">DevID_t CreateDevice(const std::string&amp; name, Mode mode);</div><div class="line">IDevice* GetDeviceInstance(DevID_t id);</div><div class="line">std::string GetDeviceName(DevID_t id);</div><div class="line">Status RemoveDevice(DevID_t id);</div></div><!-- fragment --><p> <b>IPiris</b> is the main interface for manipulation with the driver instance. It is actually a Smart Pointer of type IDevice typedef <b>SmartPointer&lt;IDevice&gt; IPiris</b>. Functions of this interface are described in the table below. <a class="el" href="namespace_a_t_esystem___p_i_r_i_s.html#a090ea6e64fd30138bbba4cee2a4403a2">SetAbsolute()</a> function is important to set values of the parameters, it can be called either directly with numeric values for focus, zoom, aperture and IR filter or with usage of class <b>FocusZoomIris&lt;T&gt;</b>, which wraps up these values into a generic container. This container serves also to return the values and state information from the functions <b><a class="el" href="namespace_a_t_esystem___p_i_r_i_s.html#ae0feb763c5f4f80505d0c692c6620bfa">ReadPosition()</a></b>, <b><a class="el" href="namespace_a_t_esystem___p_i_r_i_s.html#a5f9e4ecce3fb76efa7ed42059b9f835b">ReadParams()</a></b>, <b><a class="el" href="namespace_a_t_esystem___p_i_r_i_s.html#a7a251cfddb4c618d3a5205e0e48ccce3">ReadState()</a></b>, therefore it is sometimes more advantageous to use the first way, whereas in other cases the container might serve better. <a class="el" href="namespace_a_t_esystem___p_i_r_i_s.html#a726e051333637454489df70f43858986">SetRelative()</a> function can be used in some cases, which sets, unlike the previous function, relative values.</p>
<p><b>It is essential to call <a class="el" href="namespace_a_t_esystem___p_i_r_i_s.html#a8a0bf23c68c1775033102d008d96ce19">ReadID()</a> directly after <a class="el" href="namespace_a_t_esystem___p_i_r_i_s.html#ac1364c4840c40ee3ae26b035f3dddaea">Open()</a>, in order to correctly detect compatible firmware version!</b> </p><div class="fragment"><div class="line">Interface IDevice</div><div class="line">{</div><div class="line">public:</div><div class="line"></div><div class="line">    virtual Status Open(void* dev, PirisDeviceType type, VerboseLevel verbose) = 0;</div><div class="line">    virtual Status Open(const PirisDevice&amp; dev, VerboseLevel verbose) = 0;</div><div class="line">    virtual Status Close() = 0;</div><div class="line"></div><div class="line">    virtual std::tuple&lt;StatusEx, DataID&gt; ReadID() = 0;</div><div class="line">    virtual std::tuple&lt;StatusEx, DataPosition&gt; ReadPosition() = 0;</div><div class="line">    virtual std::tuple&lt;StatusEx, DataParams&gt; ReadParams() = 0;</div><div class="line">    virtual std::tuple&lt;StatusEx, DataState&gt; ReadState() = 0;</div><div class="line"></div><div class="line">    virtual StatusEx DevReset() = 0;</div><div class="line">    virtual StatusEx DevHoming() = 0;</div><div class="line"></div><div class="line">    virtual StatusEx SetAbsolute(uint16_t focus = 0, </div><div class="line">                                 uint16_t zoom = 0, </div><div class="line">                                 uint16_t iris = 0, </div><div class="line">                                 bool ir_filter = false) = 0;</div><div class="line">    virtual StatusEx SetAbsolute(const FocusZoomIris&lt;uint16_t&gt;&amp; values, </div><div class="line">                                 bool ir_filter = false) = 0;</div><div class="line">    virtual StatusEx SetRelative(int16_t focus = 0, </div><div class="line">                                 int16_t zoom = 0, </div><div class="line">                                 int16_t iris = 0) = 0;</div><div class="line">    virtual StatusEx SetRelative(const FocusZoomIris&lt;int16_t&gt;&amp; values) = 0;</div><div class="line"></div><div class="line">    virtual YesNoNA GetFwPollSupport() = 0;</div><div class="line">    virtual VerboseLevel GetVerboseLevel() = 0;</div><div class="line">    virtual void SetVerboseLevel(VerboseLevel level) = 0;</div><div class="line"></div><div class="line">    virtual ~IDevice() = 0;</div><div class="line">};</div></div><!-- fragment --><p> Device search is done using two static functions, which return vector of corresponding objects / descriptors based on type of main instance. <b>Pylon::CDeviceInfo</b> is a descriptor of UART/Ethernet devices, <b>serial::PortInfo</b> is a descriptor of RS232 descriptors. Those objects serve to create instance of class PirisDevice, which always describes only one device / product and which serves as a main input object of function Open(const PirisDevice&amp; dev). </p><div class="fragment"><div class="line">static int16_t ScanEthernet(std::vector&lt;Pylon::CDeviceInfo&gt;&amp; devices, bool verbose);</div><div class="line">static int16_t ScanSerial(std::vector&lt;serial::PortInfo&gt;&amp; devices, bool verbose);</div></div><!-- fragment --><p> <b>Note:</b> With any firmware prior to <b>1.5.2</b> (included) it was impossible to continually read state of the unit during any action (a command was sent, action was performed and upon its completion a reply message was returned <em>OK&lt;CR&gt;&lt;LF&gt;</em>). It was therefore not known how long it would take to complete the action. This behaviour is corrected since the release of the next firmware version <b>1.7.2</b>. A command is sent, a reply is sent immediately, and the required action starts. When the action being performed, it is advisable to cyclically query the status (GS) and check <em>motors_busy</em> state, which is True when an action is performed, False otherwise. </p><h3>Class Diagram</h3>
<img src="./ClassDiagram.png" alt="image" class="inline"/>
<h3>Examples</h3>
<p><em>Shared</em> folder includes source code of functional examples named example, which demonstrate all the features of the driver for both the UART/Ethernet and RS232 unit. Bin folder includes corresponding executable files separately for Linux OS (x86, x64, ARM, ARM64) and Windows OS (x86, x64). When using Windows, it is necessary to have the VC++ Redistributable 2013 and 2017 packages installed (from install folder). In case the target machine does not have Pylon 5 runtime installed, it is necessary to install it. Either official installers files from www.baslerweb.com or attached dynamic libraries (separate version depending on OS version and CPU architecture) can be used. When using Windows, dynamic libraries are automatically preferred (attached in the same directory).</p>
<p>OS Windows offers <b>Pylon GUI</b> for the UART/Ethernet version. When the demonstration application is started in Ethernet mode, a window with live preview from the camera is opened. If the GUI does not work or is not required, the example can be started with <b>&ndash;no-gui</b> parameter. Settings of the camera parameters must be done prior to starting the demo or a default configuration file can be used with Basler camera <b>acA2040-35gmATE.pfs</b>. If this file within the same directory as the demo, user is prompted to confirm the upload of the configuration to the camera. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
